# Next.js Client and Server Runtime: A Comprehensive Guide

## Table of Contents

1.  [Architecture Overview](#architecture-overview)
2.  [Component Types](#component-types)
3.  [Server Actions & Functions](#server-actions--functions)
4.  [Utility Files Execution Context](#utility-files-execution-context)
5.  [Async Operations](#async-operations)
6.  [Common Patterns & Scenarios](#common-patterns--scenarios)
7.  [Best Practices](#best-practices)
8.  [Caching Strategies](#caching-strategies)
9.  [Performance Implications](#performance-implications)
10. [Quick Summary](#quick-summary)

## Architecture Overview

Next.js employs a hybrid rendering model combining server-side and client-side execution:

| Rendering Type  | Description                                         | Use Cases                                 |
| --------------- | --------------------------------------------------- | ----------------------------------------- |
| **Server-Side** | Code executes on the server, sends HTML/RSC payload | Data fetching, SEO, secure operations     |
| **Client-Side** | Code executes in the browser                        | Interactive UI, user events, client-state |

## Component Types

### Server Components (Default)

```tsx
// No directive needed - this is a server component by default
import { getServerData } from "@/lib/data";

export default async function ProductPage() {
  // This runs ONLY on the server
  const data = await getServerData();

  return <div>{data.title}</div>;
}
```

**Characteristics:**

- Execute exclusively on the server
- Cannot use client-only hooks (useState, useEffect, etc.)
- Can directly access server resources (databases, file system)
- Result is streamed to the client as an RSC payload
- Cannot have event handlers (onClick, etc.)

**RSC Payload:** The "React Server Component Payload" isn't HTML. It's a special, compact binary format describing the UI structure generated by the server component. It includes rendered server components and placeholders for client components and the props they need.

**Streaming:** Server Components enable UI streaming. The server can send the initial parts of the UI (like the shell) immediately while still rendering heavier data-dependent parts. This improves perceived performance as the user sees content faster, which progressively updates as data arrives.

### Client Components

```tsx
"use client"; // Required directive

import { useState } from "react";

export default function Counter() {
  // This runs on both server (initial render) and client (interactions)
  const [count, setCount] = useState(0);

  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}
```

**Characteristics:**

- Execute on both server (initial HTML) and client (hydration)
- Can use browser APIs and React hooks
- Support interactivity
- Cannot directly access server-only resources

**Hydration:** This is the process where React on the client-side takes the server-rendered static HTML and makes it interactive by attaching event listeners and initializing the component's state. This happens after the client component's JavaScript code has loaded.

## Server Actions & Functions

### Server Actions

```tsx
// File: actions.ts
"use server"; // Required directive

import { cookies } from "next/headers"; // Server-only API

export async function updateUserPreference(preference: string) {
  // This ALWAYS runs on the server
  cookies().set("preference", preference);
  await updateDatabase(preference);
  return { success: true };
}
```

**Characteristics:**

- Defined with `"use server"` directive
- Always execute on the server
- Can be imported and called from client components
- Return serializable data to client
- Can access server-only APIs

### From Your Project Example: Auth Server Action

```tsx
// File: get-auth.ts
"use server";

import { cookies } from "next/headers";
import { lucia } from "@/lib/lucia";

export const getAuth = async () => {
  const sessionId = (await cookies()).get(lucia.sessionCookieName)?.value;
  // ...more code that runs on server
};
```

### Using Server Actions in Client Components

```tsx
// Client component using a server action
"use client";

import { useState, useEffect } from "react";
import { serverAction } from "@/actions"; // Server action with "use server" directive

export default function ClientComponent() {
  // ❌ Won't work - can't directly use async function in component rendering
  // const data = serverAction(); // Returns a Promise, can't be used synchronously

  // ✅ Correct pattern - using useState + useEffect
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchData = async () => {
      const result = await serverAction();
      setData(result);
      setLoading(false);
    };
    fetchData();
  }, []);

  // ✅ Also correct - using in event handlers
  const handleClick = async () => {
    const result = await serverAction(formData);
    // Process result
  };

  return (
    <div>
      {loading ? "Loading..." : JSON.stringify(data)}
      <button onClick={handleClick}>Submit</button>
    </div>
  );
}
```

**Important Constraints:**

- Server actions **cannot** be used directly in the component rendering flow
- This limitation exists because:
  - React component rendering is synchronous
  - Server actions are asynchronous (they return Promises)
- Server actions **can** be used in:
  - `useEffect` hooks (for data fetching)
  - Event handlers (onClick, onSubmit, etc.)
  - Form actions (via the action prop)
  - Other async contexts (like React Query's queryFn)

These constraints apply even if your server action doesn't use dynamic APIs like `cookies()` - it's a fundamental limitation of React's component model.

### Server Actions vs. Direct Data Fetching

```tsx
// Server component with direct data fetching - no server action needed
export default async function ProductsPage() {
  // Direct data fetching works perfectly well in server components
  const response = await fetch("https://api.example.com/products");
  const products = await response.json();

  return (
    <div>
      <h1>Products</h1>
      <ul>
        {products.map((product) => (
          <li key={product.id}>{product.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

**Important distinction:**

- **Server components do NOT require server actions for data fetching**
- You can use `fetch`, database clients, or any async function directly in server components

So when should you use server actions?

1. **Data Mutations**: Server actions are ideal for handling form submissions, updates, and other data mutations
2. **Client Component Access to Server Code**: When you need client components to execute server-side code
3. **Reusability**: When you need the same server operation to be accessible from multiple components
4. **Progressive Enhancement**: Server actions work even without JavaScript enabled
5. **Security**: For operations requiring authentication, validation, or other security measures

**Rule of thumb:**

- For reading data in server components: direct fetching is simpler
- For mutating data or actions from client components: server actions are necessary

### Server Actions Must Be Async

Server actions in Next.js must always be declared as `async` functions, even if they don't contain any asynchronous operations internally:

```tsx
// This will cause a build error
"use server";
export function nonAsyncServerAction() {
  // ❌ Error
  return { success: true };
}

// This is required
("use server");
export async function correctServerAction() {
  // ✅ Correct
  return { success: true };
}
```

This is a framework requirement because:

1. **Server-Client Communication**: All server actions are executed on the server and return results to the client, which is inherently asynchronous
2. **Promise-based Infrastructure**: The underlying infrastructure for server actions relies on Promises
3. **Framework Enforcement**: Next.js enforces this requirement at build time

This async requirement is one of the reasons why server actions can't be used directly in the component rendering flow of client components - they always return Promises that need to be handled in an asynchronous context.

## Utility Files Execution Context

| File Type               | Execution Context                            | Example                                  |
| ----------------------- | -------------------------------------------- | ---------------------------------------- | --- |
| **Regular Utils**       | Runs where imported (server or client)       | `src/utils/currency.ts`                  |
| **Server Action Utils** | Always runs on server                        | `src/features/auth/queries/get-auth.ts`  |
| **Client-Only Utils**   | Always runs on client (needs `"use client"`) | Files with browser APIs + `"use client"` |     |

### Regular Utility Function Example

```tsx
// utils/format.ts
// No directive - runs in the context where it's imported

export function formatCurrency(amount: number) {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
  }).format(amount);
}

// This works in both client & server components
```

## Async Operations

### Server Component Async

```tsx
// page.tsx
// Server component (default)

export default async function Page() {
  // Async operation runs on server
  const data = await fetch("https://api.example.com/data");
  const json = await data.json();

  return <div>{json.title}</div>;
}
```

### Client Component Async (useEffect pattern)

```tsx
// client-component.tsx
"use client";

import { useState, useEffect } from "react";
import { fetchServerData } from "@/actions/data"; // Server action

export default function ClientComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // Async operation runs on client but calls server action
    async function getData() {
      const result = await fetchServerData();
      setData(result);
    }
    getData();
  }, []);

  return <div>{data?.title || "Loading..."}</div>;
}
```

### From Your Project: Client Header with Server Auth

```tsx
// header.tsx
"use client";

import { getAuth } from "@/features/auth/queries/get-auth"; // Server action
import { useState, useEffect } from "react";

export default function Header() {
  const [user, setUser] = useState(null);

  useEffect(() => {
    const fetchUser = async () => {
      // Client code calling server action
      const { user } = await getAuth();
      setUser(user);
    };
    fetchUser();
  }, []);

  // Rest of component
}
```

## Common Patterns & Scenarios

### 1. Data Fetching in Server Components

```tsx
// Server component fetching data
export default async function ProductsList() {
  const products = await fetchProducts(); // Runs on server
  return (
    <ul>
      {products.map((p) => (
        <li key={p.id}>{p.name}</li>
      ))}
    </ul>
  );
}
```

### 2. Server Actions for Form Submissions

```tsx
// Form with server action
export default function ContactForm() {
  return (
    <form action={submitContact}>
      <input name="email" type="email" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### 3. Client Component with Server Data

```tsx
// Pattern seen in your header.tsx
"use client";

import { serverAction } from "./actions";
import { useState, useEffect } from "react";

export function ClientWithServerData() {
  const [data, setData] = useState(null);

  useEffect(() => {
    serverAction().then(setData);
  }, []);

  return data ? <div>{data.value}</div> : <div>Loading...</div>;
}
```

## Best Practices

1.  **Keep Components Server-First**: Start with server components and only add `"use client"` when needed

2.  **Isolate Client Components**: Create small client components for interactive parts

3.  **Use Server Actions for Mutations**: All data mutations should use server actions

4.  **Server-Only APIs Check**: Functions using server-only APIs must have `"use server"` directive if called from client components

5.  **Utility Functions Placement**:

    - General utilities: `/utils` (context-agnostic)
    - Server-only utilities: `/server` or use `"use server"` directive
    - Client-only utilities: `/client` or use `"use client"` directive

6.  **Secure Operations**: Always perform authentication, data validation, and sensitive operations in server context

7.  **Error Handling**: Server actions should have proper error handling before returning to client

8.  **Third-Party Libraries**: If a library relies heavily on browser APIs or hooks (`useState`, `useEffect`), it generally needs to be used within a Client Component (`"use client"`). Check library documentation for server component compatibility. Sometimes, you might wrap a third-party client component inside your own client component.

## Caching Strategies

Next.js employs multiple caching layers to optimize performance:

- **Data Cache**: Persists the results of data fetching operations (like `fetch`) across requests. Configurable revalidation strategies (time-based, on-demand) allow controlling data freshness.
- **Full Route Cache**: Automatically caches Server Components and their RSC payloads at build time (for static routes) or on the first request (for dynamic routes). Invalidated by deployments or revalidation.
- **Router Cache**: A client-side cache storing RSC payloads for visited routes, enabling instant back/forward navigation and prefetching.

Understanding these helps optimize data fetching and page load times.

## Performance Implications

- **Server Components**: Reduce the amount of JavaScript shipped to the client, leading to faster initial page loads and Time To Interactive (TTI). The server handles more work.
- **Client Components**: Increase the client-side JavaScript bundle size. Large or numerous client components can negatively impact performance. Optimize by keeping them small and lazy-loading where possible.
- **Server Actions**: Avoid client-side API routes for mutations, potentially simplifying architecture. Network latency between client and server affects the perceived speed of actions.
- **Streaming**: Improves perceived performance by showing content faster, even if the total server rendering time is the same.

---

## Quick Summary: Key Concepts

### The Correct Next.js Client-Server Model

- **Server Components**:

  - Execute _only_ on the server.
  - Send RSC (React Server Component) payload to the browser.
  - _Cannot_ use client-side hooks (useState, useEffect, etc.).
  - Have direct access to server resources (databases, filesystem, etc.).

- **Client Components (`"use client"`)**:

  - Execute on _both_ the server (initial HTML) and client (interactivity).
  - _Can_ use client-side hooks and browser APIs.
  - _Cannot_ directly access server-only resources.

- **Server Actions (`"use server"`)**:

  - Functions that run _exclusively_ on the server.
  - Can be imported/called from client components.
  - Return serializable data to the client.
  - Have access to server-only APIs (cookies, headers, etc.).

- **General Utility Functions (No Directive)**:
  - Run in the context where they're imported (client or server).
  - _Cannot_ use server-only APIs when running on the client.

### Key Takeaway from Code Example

The crucial point, especially highlighted by the `Header` component example:

- Functions using **server-only APIs** (like `cookies()`) **must** either:
  - Be part of a Server Component (not suitable for interactive UI).
  - Use the **`"use server"`** directive if called from Client Components.
